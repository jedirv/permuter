'''
Created on Feb 23, 2014

@author: irvine
'''
import cluster_script
class SpecHelp(object):
    '''
    classdocs
    '''


    def __init__(self):
        '''
        Constructor
        '''
    def express(self):   
        print("#pspec")
        print("# The very first line of the file must start with #pspec")
        print("############################################################################")
        print("  command - one or more command lines specify which commands to run.  ")
        print("      - to enable concise command lines, <replace> declarations elsewhere ")
        print("        in the file can be used to enable cleaner command lines ")
        print("      - each command line can contain permuters (declared elsewhere ")
        print("        in this file) that control parameter choice")
        print("      - each permuter is contained in parenthesis, i.e. (t_val)")
        print("      - the algorithm must either: ")
        print("             1. allow the output dir to be passed in as an argument")
        print("                AND hardcode the output filename")
        print("                     OR")
        print("             2. allow the output filepath to be passed in as an argument")
        print("                in which case append the output_filename to the ")
        print("                <permutation_result_dir> string like this: ")
        print("                <permutation_result_dir>/outfile.txt")
        print("        This enables status commands to function")
        print("      - <permutation_output_dir> is computed automatically for each permutation")
        print("        using this scheme <root_dir>/<cspec_name>/results/<permCode>")
        print("        where permCode is built from the permute variables, values, and trial number")
        print("        NOTE : root_dir is defined by the user in the cspec (see below)")
        print("        NOTE : trial is the value of the specific trial from among the value of 'trials:'")
        print("        NOTE : <permCode> is a code representing a particular permutation.  It is")
        print("        computed by permuter (i.e. not specified by the user)")
        print("############################################################################")
        print("command:<alg_dir>/some_algorithm -i (year)/(month)/mydata.csv -o <permutation_result_dir>/rawresult.csv -t (t_val)")
        print("command:<alg_dir>/post_processor -i <permutation_result_dir>/rawresult.csv -o <permutation_result_dir>/finalresult.csv")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# replace:   (version 0.3)")
        print("# <replace>: (version 1.0)")
        print("#       - replace statements allow for long pathnames to be compressed. Consider")
        print("#       the pathname /one/two/three/four/five/six/seven/eight/nine/ten.")
        print("#       This pathname can be represented as <aaa>/four/five/six/seven/eight/nine/ten")
        print("#       if there is a replace:aaa=/one/two/three")
        print("#       ")
        print("#       Taking a step further, defining replace:bbb=aaa/four/five/six/seven")
        print("#       will evaluate to full path if you use <bbb>/eight/nine/ten")
        print("#       ")
        print("#       <replace>: statements can nest (permuter expressions in addition to other replace ")
        print("#       statements.")
        print("############################################################################")
        print("<replace>:project_root=/nfs/ride_dir")
        print("<replace>:fv_root=<project_root>/fv")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# root_dir - used to compute <permutation_output_dir as follows: ")
        print("#       ")
        print("      - <permutation_output_dir> is computed automatically for each permutation")
        print("        using this scheme <root_dir>/<cspec_name>/results/<permCode>")
        print("        where permCode is built from the permute variables, values, and trial #")
        print("        NOTE : root_dir is defined by the user in the cspec (see below)")
        print("        NOTE : trial is the value of the specific trial from among the value of 'trials:'")
        print("        NOTE : <permCode> is a code representing a particular permutation.  It is")
        print("        computed by permuter (i.e. not specified by the user)")
        print("#       ")
        print("#       So, as should be obvious, root_dir is the root directory for all")
        print("#       files generated by this spec")
        print("############################################################################")
        print("root_dir:/someDir/myRuns")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# permute - permute declarations specify variables that hold a range of one  ")
        print("#       or more values.  For each permutation, that variable will be replaced ")
        print("#       by the appropriate value from the list.")
        print("#")  
        print("#       In version 0.3, it is permute:, in version 1.0, is is (permute):")   
        print("#")     
        print("# example permute declarations:")
        print("#       (permute):month=08,09,10       # comma separated list of strings")
        print("#       (permute):year=2010,2011,2012  # comma separated list - numbers are")
        print("#                                     # just treated as strings")
        print("#       (permute):t_val=range(3,6)     # generates a range of integers - this")
        print("#                                     # would resolve to 3,4,5,6")
        print("#         (NOTE - in version 0.3, range used to be expressed as permute:t_val=3 6)")
        print("#")
        print("#       (permute):state=Washington,Oregon,California       # any strings that lack , || = || : are ok")
        print("#       (permute):t_val= 7 # singletons ok")
        print("#")
        print("#       Elsewhere in the file, permute values are expressed inside parentheses:  (year)")
        print("# example permute expressions in use:")
        print("#       command:/somedir/some_algorithm -i (year)/(month)/mydata.csv -o <permutation_result_dir>/rawresult.csv")
        print("# ")
        print("#       permute values can be used to pick which dataset to use, or which ")
        print("#       algorithm arguments to use.  In fact, permute expressions can be used anywhere")
        print("#       in the command line or in replace expressions.")
        print("# ")
        print("#       SPECIAL CASE - what if the algorithm you wrote expects a single argument")
        print("#       that is a comma separated list?")
        print("#       For this, we've added an escaped-comma syntax that works like this:")
        print("#       permute declaration looks like this:      (permute):1_comma_foo,2,3")
        print("#       resolved argument would look like :       1,foo  ")
        print("#       this value would be represented in permutation code a.k.a pcode as: '1-foo'")
        print("############################################################################")
        print("permute:t_val=1,2,3")
        print("  ")
        print("  ")
        print("############################################################################")
        print("OPTIONAL")
        print("# concise_print - permuters and permute values are used in filenames.  To help ")
        print("# make these more readable, the  concise_print declaration specifies a shorthand ")
        print("# code for each value")
        print("############################################################################")
        print("concise_print:a_val,a")
        print("concise_print:b_val,b")
        print("concise_print:typeXYZ,xyz")
        print("concise_print:s_val,s")
        print("concise_print:t_val,t")
        print("concise_print:k_val,k")
        print("concise_print:AlUdRawCounts,Raw")
        print("concise_print:AlUdCoUq,CoUq")
        print("  ")
        print("  ")
        print("############################################################################")
        print("OPTIONAL")
        print("# first_job_number - each permutation is assigned a one-up number to make it easier ")
        print("#       to keep track of them.  ")
        print("#       For example,  'j00' in 'j00_t_1_f_3_trial_2'")
        print("#       Since the remainder of the job name can become quite dense (denser the ")
        print("#       more permuters in play), the number can be an easier way to discriminate")
        print("#       job and file names.  The number series will start at the first_job_number value, ")
        print("#       so if you have two cspecs in play, you might want to start the numbering ")
        print("#       for one of them at 0 and another at 1000 (j1000_t_5_f_70_trial2")
        print("############################################################################")
        print("first_job_number:0")
        print("  ")
        print("  ")
        
        '''
        print("############################################################################")
        print("# scores_permute - scores_permute is an optional special permuter.  It is used")
        print("#       when a single permutation run generates multiple output files. In other")
        print("#       words, there are more than one file which contain answer values that ")
        print("#       need to be collected by the 'collect' command.  It has no effect unless")
        print("#       the scores_permuter is referenced by the scores_from field, which must")
        print("#       replicate the output file path. See the scores_from for an example.")
        print("#  ")
        print("#  ")
        print("############################################################################")
        print("scores_permute:resolution=userDay,userMonth")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# scores_from - This field is not optional as it serves one primary purpose ")
        print("#       in addition to an optional one.  In order for the stat commands to ")
        print("#       work, they need to know where the output files are so they can see")
        print("#       if they have been created yet.  Since permuter.py is not smart enough")
        print("#       to deduce which 'command:' line's substring represents the output file, ")
        print("#       that information needs to be exactly replicated in the scores_from field.")
        print("#       ")
        print("#       The value of the scores_from field is a comma separated list.  This ")
        print("#       supports the optional purpose, which is the 'collect' command.  In order")
        print("#       for the collect command to find the numeric 'answer' for the run, it  ")
        print("#       needs to know the coordinates of that number, which is expressed like this:")
        print("#       ")
        print("#       pathname_of_the_file, column_name_of_answer, line_number_of_answer")
        print("#       ")
        print("#       Note that if you are not using collect, you need to put bogus values")
        print("#       in for column_name_of_answer, line_number_of_answer to keep the spec")
        print("#       parser from throwing an error.")
        print("#       ")
        print("#       If scores_permute: is in play, it would appear in the scores_from pathname.")
        print("#       We'll show two examples - one with and one without scores_permute")
        print("############################################################################")
        print("scores_from:file=<permutation_output_dir>/score_out_(resolution).csv,column_name=auc,row_number=1")
        print("scores_from:file=<permutation_output_dir>/score_out.csv,column_name=auc,row_number=1")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# scores_to - This field specifies the root dir of where the collected scores")
        print("#       will be put.  It is only needed if 'collect' is being used")
        print("############################################################################")
        print("scores_to:/some_dir/collected_scores")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# scores_y_axis:")
        print("# scores_x_axis: - these two fields work together to support the collect command.")
        print("#       They can be omitted if 'collect' will not be used.")
        print("#       ")
        print("#       Let's say you have four permuters in play: month, fv_type, f_val and t_val.")
        print("#       When collect runs, it will want to know how to combine scores that it finds.")
        print("#       Collect is currently rigged to ...   ADD MORE HERE")
        print("############################################################################")
        print("scores_y_axis:month,fv_type")
        print("scores_x_axis:f_val,t_val")
        print("  ")
        print("  ")
        '''
        print("############################################################################")
        print("# complicated tricks with replace and permute - ")
        print("#       Let's say I have to match a directory pattern to reference input files")
        print("#       where the dir pattern looks like")
        print("#           /foo/2010/abc/input.csv")
        print("#           /foo/2011/abc/input.csv")
        print("#           /foo/2012/xyz/input.csv")
        print("#       ")
        print("#       Note how abc appears under both 2010 and 2011, but xyz appears under 2012")
        print("#       If we have:")
        print("#           (permute):year=2010,2011,2012")
        print("#           <replace>:config_for_year[2010]=abc")
        print("#           <replace>:config_for_year[2011]=abc")
        print("#           <replace>:config_for_year[2012]=xyz")
        print("#       ...then the following would resolve these correctly, since the permuter")
        print("#       would be resolved, then the replace would be resolved.")
        print("############################################################################")
        print("<replace>:input_file=/foo/(year)/<config_for_year[(year)]>/input.csv")
        print("  ")
        print("  ")
        print("############################################################################")
        print("OPTIONAL")
        print("# launch_interval - used to control delay between qsub calls during launch or retry ")
        print("#       ")
        print("############################################################################")
        print("launch_interval:1.5")
        print("  ")
        print("  ")
        print("############################################################################")
        print("OPTIONAL")
        print("#  trials - specify the number of trials you want to run. Each permutation  ")
        print("#           will be run that many times.  Value must be integer.")
        print("############################################################################")
        print("trials:1")
        print("  ")
        print("  ")
        '''
        print("############################################################################")
        print("# script_dir - the location where scripts will be generated.  It will also be ")
        print("#       where .qil, .err, .out, .qacct files are put.   Here's what each of these is")
        print("#       ")
        print("#       *.err - file generated for each script that captures errors emitted by the script")
        print("#       *.out - receives stdout from the script and algorithm")
        print("#       *.qil - 'qsub invocation log' captures output of the qsub commands which includes")
        print("#                the cluster job number.  This allows permuter to tie its job numbers to")
        print("#                the job number known to the cluster")
        print("#       *.qacct - after a run is finished, 'collect' wants to know stats of the run such")
        print("#                as cpu time, maxvmem, etc.  the cluster command 'qacct run#' yields that ")
        print("#                info and it is captured in this file")
        print("#                NOTE - qacct takes a long time to run so collect can take a good while ")
        print("#                if the job count is high. ")
        print("############################################################################")
        print("script_dir:<project_root>/<cspec_name>/scripts")
        print("  ")
        print("  ")
        '''
        print("############################################################################")
        print("# qsub_command: - these values are routed into each script file and wind up ")
        print("#       with the syntax: ")
        print("#       ")
        print("#       #$ some_value")
        print("#       ")
        print("#       For example, ")
        print("#       ")
        print("#       qsub_command:-q eecs,eecs2,share")
        print("#       ")
        print("#       ...specifies which queues are requested")
        print("#       ")
        print("#       ")
        print("#       NOTE - some script content is automatically generated, such as specifying ")
        print("#       a name for the run - it includes the one-up run number, the trial number ")
        print("#       and permutation code and t.")
        print("#       #$ -N runtest-j00_1_x_1_y_1_1")
        print("#       ")
        print("#       Also automatically generated are filenames for error and stdout content to ")
        print("#       be routed to:")
        print("#       ")
        print("#       #$ -o j00_1_x_1_y_1.out")
        print("#       #$ -e j00_1_x_1_y_1.err")
        print("#       ")
        print("#       NOTE - the string '#$-cwd\n' is added to the script automatically to ensure that ")
        print("#       *.qil, *.err, *.out, *.acct files are routed to the appropriate dir (i.e.")
        print("#       the script dir) ")
        print("#       ")
        print("#       ")
        print("#############################################################################")
        print("qsub_command:-q eecs,eecs2,share")
        print("  ")
        print("  ")
        print("############################################################################")
        print("# ASSUMPTIONS of permuter.py")
        print("############################################################################")
        print("#   - the output pathname of the run is exposed as an argument thus appears as ")
        print("#     a substring of one of the command: fields")
        print("#")
        #print("#   - the output pathname of the run is replicated as the first field of the ")
        #print("#     scores_from value")
        #print("#")
        #print("#   - for collect to function, it is assumed that the answer of interest (the")
        #print("#     one that will be collected) is located in a csv file, which has a header")
        #print("#     line where the column containing the answer has a name, and is in the 2nd or")
        #print("#     later line of the file.")
        #print("#")
        print("#   - qsub_command:-cwd for now needs to be included in the spec to ensure that ")
        print("#     *.qil, *.err, *.out, *.acct files are routed to the appropriate dir (i.e.")
        print("#      the script dir) ")
        print("#")
        print("############################################################################")
        print("# OTHER NOTES")
        print("############################################################################")
        print("#  - permuter.py appends a command to each script that touches a file in the ")
        print("#  results dir for each run, with this name ")
        print("#  ")
        done_file = cluster_script.get_done_marker_filename()
        print("#  touch <permutation_output_dir>/{0}".format(done_file))
        print("#  ")
        print("#  This file is used to signal that the script has run through all of its commands.")
        print("#  It does not signify that all commands ran error-free.  It is used by the stat")
        print("#  commands to help assess the state of the runs")
        print("#  ")
        print("#  - If you return to a permutation workspace and can't remember if the scripts, ")
        print("#  and run results belong to the pspec in its current form or from prior to editing it,")
        print("#  look at the start of <root_dir>/<spec_dir>/permuter.log as the pspec contents")
        print("#  that drove the contents of the most recent runs were copied there.")

        print("############################################################################")
        print("# GOTCHAS")
        print("############################################################################")
        print("#  Here are some ways that certain maneuvers can lead to confusion or corruption ")
        print("#  of your work permutation workspace (the files under <root_dir>/<spec_name>)")
        print("#  ")
        print("#  GOTCHA 1: drifting spec leaves orphan scripts around ")
        print("#  HOW - generate scripts, adjust permutation space in pspec, regenerate scripts")
        print("#  CONSEQUENCE: orphan scripts remain, polluting the landscape ")
        
        print("#  GOTCHA 1: drifting spec leaves orphan scripts and results around ")
        print("#  HOW - generate scripts, launch runs, adjust permutation space in pspec, regenerate scripts, launch runs")
        print("#  CONSEQUENCE: orphan scripts and output files remain, polluting the landscape ")

        print("#  SOLUTION:  run clean_slate command before changing the pspec")
        print("#       OR")
        print("#  SOLUTION:  change name of pspec when you change permutation space so generated")
        print("#  files are in a different directory <root_dir>/<new_spec_name>")
        print("#  ")

